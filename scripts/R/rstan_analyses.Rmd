---
title: "bayesParcel R/Stan analyses"
author: "The Best Group Ever (Paul, Yaniv, Monica)"
date: "11/28/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(magrittr)
library(tidyverse)
theme_set(theme_bw())
library(rstan)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
library(data.table)
library(bayesplot)
library(moments)
```

## Loading real data

Under construction because Paul hasn't uploaded the data yet.

```{r}
betas_raw <- read_csv("../../ignore/harvard_ox_roi.csv")

betas <- betas_raw %>%
  gather(key = "roi", value = "value", -Subject, -wave, -meanFD_included_trs) %>%
  filter(!is.na(value)) %>%
  mutate(statistic = if_else(grepl("Mean", roi), "cope_mean", "cope_sd"),
         roi = if_else(statistic == "cope_mean",
                       str_sub(roi, end = -5L),
                       str_sub(roi, end = -3L))) %>%
  spread(statistic, value) %>%
  # BAND AID!!! but we need ot filter cope_sd > 0. some shit failed
  filter(cope_sd > 0, wave == 1) %>%
  group_by(Subject) %>%
  nest() %>%
  mutate(subject_num = 1:n()) %>%
  unnest() %>%
  group_by(roi) %>%
  nest() %>%
  mutate(roi_num = 1:n()) %>%
  unnest() %>%
  mutate(cope_mean_scaled = cope_mean / sd(cope_mean),
         cope_sd_scaled = cope_sd / sd(cope_mean))
```

ROIs to exclude*:

subcortical 1, 2, 8 (brainstem), 12, 13

## Simulating data

## Model 0: Single normal hyper-distribution

### Stan code

```{stan, output.var = "model0", results = "hide", message = FALSE, warning = FALSE}
data {
  int<lower=0> N;          // number of rois x observations (subjs x waves)
  int<lower=0> N_roi;
  int<lower=0> N_subj;
  real cope[N];               // estimated effects for each observation of roi
  int<lower=1, upper=N_roi> roi[N]; // ROI ID of each observation
  int<lower=1, upper=N_subj> subj[N]; // subject ID of each observation
  real<lower=0> fd[N]; // framewise displacement of each observation, varies by subject x wave
  real<lower=0> varcope[N];  // s.e. of effect estimates
}
transformed data {
  int<lower=0> N_cell = N_roi * N_subj;
}
parameters {
  real alpha; // intercept 
  real<lower=0> tau_roi;
  real<lower=0> tau_subj;
  vector[N_roi] eta_roi; // centered parameterization of roi-specific effect estimate
  vector[N_subj] eta_subj; // centered parameterization of roi-specific effect estimate
}
model {
  // priors make the world go round
  alpha ~ normal(0, 1);
  tau_roi ~ normal(0, 1);
  tau_subj ~ normal(0, 1);
  eta_roi ~ normal(0, 1);
  eta_subj ~ normal(0, 1);
  // completely pooled across observations here
  cope ~ normal(alpha + tau_roi * eta_roi[roi] + tau_subj * eta_subj[subj], varcope);
}
generated quantities {
  vector[N_roi] theta_roi = alpha + tau_roi * eta_roi;
  vector[N_subj] theta_subj = alpha + tau_subj * eta_subj;
  
  vector [N] rep_cope; // Create data replicates

  for (i in 1:N)
    rep_cope[i] = normal_rng(alpha + tau_roi * eta_roi[roi][i] + tau_subj * eta_subj[subj][i], varcope[i]);
}
```

```{r}
fit0 <- sampling(model0,
                data = betas %$%
                  list(N = nrow(.),
                       N_roi = max(roi_num),
                       N_subj = max(subject_num),
                       cope = cope_mean_scaled,
                       roi = roi_num,
                       subj = subject_num,
                       fd = meanFD_included_trs,
                       varcope = cope_sd_scaled),
                control = list(max_treedepth = 15))
```

```{r}
df_fit <- fit0 %>%
  as.data.frame() %>%
  as_tibble() %>%
  mutate(iteration = 1:n())

hyperparams <- df_fit %>%
  select(iteration, alpha, tau_roi, tau_subj)

eta_rois <- df_fit %>%
  select(iteration, tau_roi, starts_with("eta_roi")) %>%
  gather(key = "roi_num", value = "eta", starts_with("eta_roi")) %>%
  mutate(roi_num = as.integer(str_sub(roi_num, start = 9L, end = -2L)),
         eta_unscaled = tau_roi * eta * sd(betas$cope_mean)) %>%
  group_by(roi_num) %>%
  nest(.key = "iterations") %>%
  left_join(betas %>%
              select(roi_num, cope_mean, cope_mean_scaled) %>%
              group_by(roi_num) %>%
              summarize_all(mean),
            by = "roi_num") %>%
  mutate(summaries = map(iterations, ~.x %>%
                           summarize_at(vars(starts_with("eta")),
                                        funs(median = median,
                                             int_95_lower = quantile(., .025),
                                             int_95_upper = quantile(., .975),
                                             int_50_lower = quantile(., .25),
                                             int_50_upper = quantile(., .75))))) %>%
  unnest(summaries, .preserve = "iterations")

theta_rois <- df_fit %>%
  select(iteration, starts_with("theta_roi")) %>%
  gather(key = "roi_num", value = "theta", starts_with("theta_roi")) %>%
  mutate(roi_num = as.integer(str_sub(roi_num, start = 11L, end = -2L)),
         theta_unscaled = theta * sd(betas$cope_mean)) %>%
  group_by(roi_num) %>%
  nest(.key = "iterations") %>%
  left_join(betas %>%
              select(roi_num, cope_mean, cope_mean_scaled) %>%
              group_by(roi_num) %>%
              summarize_all(mean),
            by = "roi_num") %>%
  mutate(summaries = map(iterations, ~.x %>%
                           summarize_at(vars(starts_with("theta")),
                                        funs(median = median,
                                             int_95_lower = quantile(., .025),
                                             int_95_upper = quantile(., .975),
                                             int_50_lower = quantile(., .25),
                                             int_50_upper = quantile(., .75))))) %>%
  unnest(summaries, .preserve = "iterations")


```

### Plots?

```{r}
theta_rois %>%
  ggplot(aes(x = roi_num)) +
  geom_hline(yintercept = 0, linetype = 3) +
  geom_errorbar(aes(ymin = theta_unscaled_int_95_lower, ymax = theta_unscaled_int_95_upper), width = 0) +
  geom_point(aes(y = theta_unscaled_median)) +
  geom_point(aes(y = cope_mean), color = "hotpink") +
  labs(x = "ROI number (arbitrary)",
       y = "COPE/beta value (arbitrary units)",
       title = "Bayesian estimates against original marginal means",
       subtitle = "Black: median estimates +- 95% predictive interval, pink: original mean estimate") +
  theme_bw()
```
```{r}
# Plot data replicates
# Implemented with data.table. Sorry. Open to the possibility of recoding with tidyverse, just not right now
df_fit <- as.data.table(fit0)
df_fit <- df_fit[, grepl('rep_cope', colnames(df_fit)), with = F]
df_fit[, sim := 1:nrow(df_fit)]
df_fit <- melt(df_fit, id.vars = 'sim')
df_fit[, value := value * sd(betas$cope_mean)]
df_fit <- df_fit[, .(median = median(value),
                     lb = quantile(value, 0.025),
                     ub = quantile(value, 0.975)), by = variable][order(variable)]
df_fit[, subject_num := betas$subject_num]
df_fit[, roi_num := betas$roi_num]
df_fit[, true_value := betas$cope_mean]
df_fit <- df_fit[order(true_value)]

# Plot disregarding heirarchy
ggplot(df_fit, aes(x = 1:nrow(df_fit), y = median)) +
  geom_ribbon(aes(ymin = lb, ymax = ub), fill = 'yellow') +
  geom_line(color = 'darkred') + 
  geom_point(aes(y = true_value)) +
  labs(x = 'Observation number',
       y = 'COPE',
       title = 'Posterior predictive checks: replicate plots ignoring heirarchy',
       subtitle = 'Red: posterior median. Yellow: posterior 95% interval. Black: observed COPE')

# Plot by subject
df_subs <- df_fit[subject_num %in% sample(1:length(unique(subject_num)), 20)]
df_subs[, xplot := 1:.N, by = subject_num]
ggplot(df_subs, aes(x = xplot, y = median)) +
  geom_ribbon(aes(ymin = lb, ymax = ub), fill = 'yellow') +
  geom_point(aes(y = true_value), size = 0.3) +
  geom_line(color = 'darkred') + 
  facet_wrap('subject_num') +
  theme(strip.background = element_blank(),
    strip.text.x = element_blank()) +
  labs(x = 'subject number (arbitrary)',
       y = 'COPE',
       title = 'Posterior predictive checks: replicate plots by subject, for a random subsample of subjects',
       subtitle = 'Red: posterior median. Yellow: posterior 95% interval. Black: observed COPE')

# Plot by roi
df_subs <- df_fit[roi_num %in% sample(1:length(unique(roi_num)), 20)]
df_subs[, xplot := 1:.N, by = roi_num]
ggplot(df_subs, aes(x = xplot, y = median)) +
  geom_ribbon(aes(ymin = lb, ymax = ub), fill = 'yellow') +
  geom_point(aes(y = true_value), size = 0.3) +
  geom_line(color = 'darkred') + 
  facet_wrap('roi_num') +
  theme(strip.background = element_blank(),
    strip.text.x = element_blank()) +
  labs(x = 'Subject number (arbitrary)',
       y = 'COPE',
       title = 'Posterior predictive checks: replicate plots by ROI, for a random subsample of ROIs',
       subtitle = 'Red: posterior median. Yellow: posterior 95% interval. Black: observed COPE')

```
```{r}
# Compare thetas to priors
df_fit <- as.data.table(fit0)
vars <- colnames(df_fit)
eta_rois <- df_fit[sample(1:nrow(df_fit), 20), grepl('eta_roi', vars) & !grepl('th', vars), with = F]
eta_subj <- df_fit[sample(1:nrow(df_fit), 20), grepl('eta_subj', vars) & !grepl('th', vars), with = F]

eta_rois[, sim := 1:.N]
eta_subj[, sim := 1:.N]

eta_rois <- melt(eta_rois, id.vars = 'sim')
eta_subj <- melt(eta_subj, id.vars = 'sim')

bw <- .2
n_subj <- length(unique(eta_subj$variable))
ggplot(eta_subj, aes(x = value)) + 
  geom_histogram(binwidth = bw) +
  facet_wrap('sim') +
  stat_function(fun = function(x, bw, n) dnorm(x) * bw * n, 
                args = c(bw = bw, n = n_subj),
                color = 'blue') +
  theme(strip.background = element_blank(),
    strip.text.x = element_blank()) + 
  labs(x = expression(eta),
       title = 'Estimated ROI deviations agains the normal prior distribution',
       subtitle = 'Black: ROI histogram, Blue: normal prior, Each facet represents a posterior draw')

n_roi <- length(unique(eta_rois$variable))
ggplot(eta_rois, aes(x = value)) + 
  geom_histogram(binwidth = bw) +
  facet_wrap('sim') +
  stat_function(fun = function(x, bw, n) dnorm(x) * bw * n, 
                args = c(bw = bw, n = n_roi),
                color = 'blue') +
  theme(strip.background = element_blank(),
    strip.text.x = element_blank()) + 
  labs(x = expression(eta),
       title = 'Estimated subject deviations agains the normal prior distribution',
       subtitle = 'Black: subject histogram, Blue: normal prior, Each facet represents a posterior draw')

```


## Model 1: Finite mixture hyper-distribution

### Stan code

### Plots?
